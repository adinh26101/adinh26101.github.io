---
title: "Nhận Dạng Thiết Bị Dựa Trên Tín Hiệu Vô Tuyến Sử Dụng Deep Metric Learning"
date: 2025-09-02-rff 10:00:00 +0000
categories: [Machine Learning, Deep Learning, Radio Frequency Fingerprinting]
tags: [Radio Frequency Fingerprinting, Signal Processing, RiftNet, OpenSet Problem, Metric Learning]
author: adinh26101
icon: fas fa-chart-bar
lang: vi
math: true
permalink: /posts/rff-based-device-identify/
---

### Nội Dung
- [1. Giới thiệu](#-introduction)
- [2. Các nghiên cứu liên quan](#-related-work)
- [3. Phương pháp](#-method)
- [4. Thử nghiệm](#-experiment)
- [5. Kết quả](#-result)


<a name="-introduction"></a>  
## 1. Giới thiệu

**Radio Frequency Fingerprinting (RFF)** là kỹ thuật nhận dạng thiết bị vô tuyến dựa trên đặc trưng duy nhất (*fingerprint*) phát sinh từ **sai lệch phần cứng** trong quá trình truyền tín hiệu RF.

<p>
    <img src="assets/2025-09-02-rff/signal_component.png" alt="Thành phần cơ bản của tín hiệu"/>
</p>

- Mỗi thiết bị (WiFi, IoT, điện thoại, drone, v.v.) khi phát sóng đều có những **lỗi nhỏ không thể tránh** trong mạch (*oscillator, PA, DAC...*).  
- Những sai lệch này tạo nên một **“dấu vân tay” điện từ** riêng biệt.  
- Bằng cách **trích xuất các đặc trưng** này từ tín hiệu nhận được (ví dụ: *IQ imbalance, phase noise, transient, spectral features*…), ta có thể xác định và phân biệt thiết bị ngay cả khi chúng dùng **cùng chuẩn truyền thông và địa chỉ MAC/IP**.  

### Ứng dụng chính của RFF
- **An ninh mạng không dây**: phát hiện giả mạo, ngăn spoofing.  
- **IoT**: nhận dạng và xác thực thiết bị nhẹ nhàng, không cần giao thức nặng.  
- **Quân sự & Drone**: phân biệt máy bay không người lái.  

<a name="-related-work"></a>  
## 2. Các nghiên cứu liên quan

### Nhận dạng tín hiệu transient
Các nghiên cứu cho thấy giai đoạn *transient* trong tín hiệu vô tuyến (giữa nhiễu và ổn định) chứa nhiều đặc trưng quan trọng cho việc nhận dạng thiết bị. Việc xác định chính xác ranh giới *transient* là then chốt, tránh sai lệch ảnh hưởng đến quá trình trích xuất đặc trưng và huấn luyện.  

Hai phương pháp phổ biến để phát hiện:
- **Bayesian change point detection**: dựa trên thay đổi *fractal dimension*.  
- **Phase-Based detection**: dựa trên biến thiên pha tuyến tính trong giai đoạn *transient*.  

### Ứng dụng Học máy và Học sâu
Sau khi tách được tín hiệu *transient*, các mô hình học máy có giám sát như **SVM** cho kết quả tốt, nhưng phụ thuộc mạnh vào tính chính xác của việc tách *transient*.  

Để khắc phục, **học sâu (CNN, LSTM)** tận dụng toàn bộ tín hiệu, giảm phụ thuộc vào bước xác định *transient* và nâng cao độ chính xác. Gần đây, các mô hình như **RiftNet** được áp dụng để nhận dạng thiết bị từ tín hiệu Bluetooth của điện thoại thông minh.

<a name="-method"></a>  
## 3. Phương pháp

### Phân loại tín hiệu với Machine Learning

#### Đặc trưng pha tức thời
- Dựa trên tín hiệu *transient-based RF fingerprinting*.  
- Trích xuất các đặc trưng thống kê bậc cao: **skewness, kurtosis, variance** từ:
  - Biên độ tức thời  
  - Tần số tức thời  
  - Pha tức thời  
- Các đặc trưng này phản ánh sai lệch phần cứng vi mô, tạo “dấu vân tay” riêng cho thiết bị.

#### Đặc trưng TFED
- Sử dụng **Hilbert-Huang transform** để phân tích tín hiệu theo miền thời gian – tần số.  
- Trích xuất các nhóm đặc trưng:  
  - **Transient Signal** (ví dụ: thời lượng, năng lượng, entropy pha)  
  - **Envelope** (ví dụ: năng lượng, phương sai phong bì)  
  - **TFED-Time** (ví dụ: độ dốc, phương sai, cực đại phân bố năng lượng)  
  - **TFED-Frequency** (ví dụ: cực đại, phương sai năng lượng)  
- Hạn chế: cần **trích xuất thủ công**, phụ thuộc vào việc xác định chính xác *transient*, dễ mất thông tin khi tần số lấy mẫu thấp.

### Phân loại tín hiệu với RiftNet

<p>
    <img src="assets/2025-09-02-rff/riftnet_architecture.png" alt="Kiến trúc mô hình RiftNet"/>
    <em>Kiến trúc mô hình RiftNet</em>
</p>

- RiftNet có **hai nhánh**:  
  - Nhánh (A): xử lý đoạn tín hiệu dài (~16 μs).  
  - Nhánh (B): xử lý đoạn tín hiệu ngắn (~2.5 μs).  
- Cả hai nhánh dùng **Dilated Convolutional Cells (DCC)** với tỷ lệ giãn khác nhau để khai thác thông tin đa mức thời gian.  
- Kết quả trung gian được kết hợp bằng **skip connections** rồi đưa vào tầng phân loại.  
- Ưu điểm: khai thác hiệu quả đặc trưng RF, giảm phụ thuộc vào bước trích xuất thủ công.

### Metric Learning và Open Set Problem

- Sau khi huấn luyện **RiftNet**, lớp softmax được bỏ đi.  
- Áp dụng **metric learning** với **contrastive loss**, huấn luyện thêm **20 epoch**.  
- Trích xuất vector tiềm ẩn (latent vectors) của người dùng đã biết và lập chỉ mục bằng **FAISS** để truy vấn và đánh giá.  
- Đặt ngưỡng **1.0 (Euclidean distance)** trong không gian embedding để phân biệt **người dùng đã biết** và **người dùng chưa biết**.  

<a name="-experiment"></a>  
## 4. Thử nghiệm

### Dữ liệu
- Bộ dữ liệu công khai từ nghiên cứu của Uzundurukan et al. (2020), xuất bản ở tạp chí Data, MDPI vào năm 2020, với tiêu đề bài báo “A Database for the Radio Frequency Fingerprinting of Bluetooth Devices”.
- Link bài báo: https://www.mdpi.com/2306-5729/5/2/55
- Link bộ dữ liệu: https://doi.org/10.5281/zenodo.3876140
- Tín hiệu **Bluetooth (BT)**, tốc độ lấy mẫu **250 Msps**.  
- Gồm **13 thiết bị** thuộc **5 thương hiệu**, tổng cộng ~1950 bản ghi từ 33 điện thoại.  
- Chia dữ liệu: **80% train – 20% test**.  

**Danh sách thiết bị:** iPhone 4s, 5, 5s, 6, 6s, 7, 7 Plus, LG G4, Samsung Note 2, Note 3, S3, J7, Xiaomi Mi 6.  

### Phân loại với Machine Learning
- Mô hình sử dụng: **SVM, LDA, Decision Tree, Random Forest, XGBoost, CatBoost, Gradient Boosting**.  
- Thư viện: `scikit-learn`, `XGBoost`, `CatBoost`.  
- Dùng siêu tham số mặc định.  
- Huấn luyện và đánh giá trên cùng tập dữ liệu.  

### Phân loại với RiftNet
- Huấn luyện **100 epoch**.  
- Optimizer: **Adam**, learning rate = `1e-4`.  
- Loss function: **cross-entropy** (phù hợp cho phân loại).  

<a name="-result"></a>  
## 5. Kết quả

### Phân loại với Học máy
- **Đặc trưng pha tức thì** (Instantaneous features):  
  - SVM đạt **67.42% (train)** và chỉ **42.22% (test)** → hiệu quả thấp.  

- **Đặc trưng TFED**:  
  - LDA: 73.64% (train) / 72.93% (test)  
  - Decision Tree: 100% / 56.57%  
  - Random Forest: 100% / 69.19%  
  - XGBoost: 100% / 70.61%  
  - CatBoost: 99.12% / 72.12%  
  - Gradient Boosting: 99.55% / 65.35%  

👉 Kết quả cho thấy hiện tượng **overfitting**: mô hình đạt độ chính xác rất cao trên tập huấn luyện nhưng giảm mạnh trên tập kiểm tra. Nguyên nhân chính là **khó xác định chính xác giai đoạn transient**, khiến đặc trưng thủ công (instantaneous, TFED) chưa đủ mạnh.  

### Phân loại với RiftNet

<p>
    <img src="assets/2025-09-02-rff/riftnet_loss.png" alt="Đồ thị hàm loss trong quá trình training"/>
    <em>Đồ thị hàm loss trong quá trình training</em>
</p>

<p>
    <img src="assets/2025-09-02-rff/riftnet_train_acc.png" alt="Đồ thị accuracy trên tập train"/>
    <em>Đồ thị accuracy trên tập train</em>
</p>

<p>
    <img src="assets/2025-09-02-rff/riftnet_test_acc.png" alt="Đồ thị accuracy trên tập test"/>
    <em>Đồ thị accuracy trên tập test</em>
</p>

<p>
    <img src="assets/2025-09-02-rff/riftnet_confusion_test.png" alt="Confusion matrix trên tập test"/>
    <em>Confusion matrix trên tập test</em>
</p>

- Mô hình **hội tụ nhanh và ổn định**: loss giảm mạnh ở các epoch đầu.  
- Hiệu suất tăng đều trên cả train và test.  
- **Kết quả tốt nhất tại epoch 96**:  
  - Train accuracy: **99.4%**  
  - Test accuracy: **96.57%**  
- Có dao động nhẹ ở test do dữ liệu kiểm tra còn **nhỏ và chưa đa dạng**, dễ gây sai lệch phân bố dữ liệu (*distribution shift*).  

👉 **RiftNet vượt trội hơn hẳn** so với các mô hình học máy truyền thống, cho thấy sức mạnh của học sâu trong nhận dạng RFF.

### Kết quả Metric Learning trong Open Set

<p>
    <img src="assets/2025-09-02-rff/scatter_plot.png" alt="t-SNE plot"/>
    <em>Biểu diễn các latent vector được gom thành các cluster với t-SNE plot</em>
</p>

- Sau khi áp dụng **metric learning**, không gian latent hình thành **các cụm rõ ràng** tương ứng với người dùng đã biết.  
  - Thiết bị cùng lớp được nhóm thành các cụm gọn gàng.  
  - Các lớp khác nhau tách biệt rõ ràng.  
  - Thiết bị chưa thấy trước đó xuất hiện như **outliers**, dễ nhận diện.  

<p>
    <img src="assets/2025-09-02-rff/openset_confusion.png" alt="openset problem trên tập test (có unknown user)"/>
    <em>Openset problem trên tập test (có unknown user)</em>
</p>

- Thử nghiệm trên tập test **hỗn hợp** (cả known và unknown devices):  
  - **Confusion matrix** cho thấy dự đoán các lớp đã biết **chính xác và ổn định**.  
  - Một số nhầm lẫn xảy ra chủ yếu với lớp **unknown**, điều này là bình thường trong tình huống open-set.  
  - Với ngưỡng **1.0 (Euclidean distance)**, hệ thống đạt **97.05% độ chính xác** trong phân biệt known/unknown.  

👉 Kết quả chứng minh RiftNet kết hợp metric learning có **khả năng tổng quát cao** và tiềm năng mạnh trong **xác thực thiết bị dựa trên tín hiệu vô tuyến trong môi trường open-set**.

Bài báo được xuất bản ở hội nghị APSIPA ASC 2025, [check here]().

Code được sử dụng trong nghiên cứu nằm ở repository này, [check here](https://github.com/frogdance/rff-based-deep-metric-learning).